From 29f70980e7bd948ad4aceebeac2dd65e458d9cd1 Mon Sep 17 00:00:00 2001
From: Valentin Raevsky <valentin@compulab.co.il>
Date: Sun, 22 Jan 2023 23:27:35 +0200
Subject: [PATCH] compulab: Merge 5.15.32

Signed-off-by: Valentin Raevsky <valentin@compulab.co.il>
---
 arch/arm64/boot/dts/Makefile                  |   1 +
 drivers/gpu/drm/panel/Kconfig                 |   9 +
 drivers/gpu/drm/panel/Makefile                |   1 +
 drivers/media/platform/Kconfig                |  19 +-
 drivers/media/platform/imx8/Makefile          |   5 +
 .../media/platform/mxc/capture/mx6s_capture.c | 173 +++++++++++++++++-
 .../media/platform/mxc/capture/mxc_mipi_csi.c |  86 ++++++++-
 drivers/mtd/spi-nor/winbond.c                 |   3 +
 drivers/staging/Kconfig                       |   1 +
 drivers/staging/Makefile                      |   1 +
 drivers/staging/media/imx/imx8-isi-cap.c      | 153 ++++++++++++++++
 drivers/staging/media/imx/imx8-isi-hw.c       |   1 +
 .../staging/media/imx/imx8-mipi-csi2-sam.c    | 151 +++++++++++++++
 drivers/staging/media/imx/imx8-mipi-csi2.c    |  96 ++++++++++
 include/media/v4l2-subdev.h                   |   9 +
 15 files changed, 701 insertions(+), 8 deletions(-)

diff --git a/arch/arm64/boot/dts/Makefile b/arch/arm64/boot/dts/Makefile
index 639e01a4d855..2c0e4db6e60c 100644
--- a/arch/arm64/boot/dts/Makefile
+++ b/arch/arm64/boot/dts/Makefile
@@ -11,6 +11,7 @@ subdir-y += arm
 subdir-y += bitmain
 subdir-y += broadcom
 subdir-y += cavium
+subdir-y += compulab
 subdir-y += exynos
 subdir-y += freescale
 subdir-y += hisilicon
diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index bb2eb6808a48..c9fd333a0928 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -148,6 +148,15 @@ config DRM_PANEL_ILITEK_ILI9881C
 	  Say Y if you want to enable support for panels based on the
 	  Ilitek ILI9881c controller.
 
+config DRM_PANEL_STARTEK_ILI9881C
+	tristate "Startek ILI9881C-based panels"
+	depends on OF
+	depends on DRM_MIPI_DSI
+	depends on BACKLIGHT_CLASS_DEVICE
+	help
+	  Say Y if you want to enable support for panels based on the
+	  Startek panel with an ILI9881c controller.
+
 config DRM_PANEL_INNOLUX_EJ030NA
         tristate "Innolux EJ030NA 320x480 LCD panel"
         depends on OF && SPI
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index d15a67e92319..84e4f633f5b8 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -56,6 +56,7 @@ obj-$(CONFIG_DRM_PANEL_SHARP_LS043T1LE01) += panel-sharp-ls043t1le01.o
 obj-$(CONFIG_DRM_PANEL_SITRONIX_ST7701) += panel-sitronix-st7701.o
 obj-$(CONFIG_DRM_PANEL_SITRONIX_ST7703) += panel-sitronix-st7703.o
 obj-$(CONFIG_DRM_PANEL_SITRONIX_ST7789V) += panel-sitronix-st7789v.o
+obj-$(CONFIG_DRM_PANEL_STARTEK_ILI9881C) += panel-startek-ili9881c.o
 obj-$(CONFIG_DRM_PANEL_SONY_ACX424AKP) += panel-sony-acx424akp.o
 obj-$(CONFIG_DRM_PANEL_SONY_ACX565AKM) += panel-sony-acx565akm.o
 obj-$(CONFIG_DRM_PANEL_TDO_TL070WSH30) += panel-tdo-tl070wsh30.o
diff --git a/drivers/media/platform/Kconfig b/drivers/media/platform/Kconfig
index 3e80620d4643..38d8cd84e733 100644
--- a/drivers/media/platform/Kconfig
+++ b/drivers/media/platform/Kconfig
@@ -10,8 +10,6 @@ menuconfig V4L_PLATFORM_DRIVERS
 
 if V4L_PLATFORM_DRIVERS
 
-source "drivers/media/platform/nxp/Kconfig"
-
 source "drivers/media/platform/marvell-ccic/Kconfig"
 
 config VIDEO_VIA_CAMERA
@@ -27,7 +25,6 @@ config VIDEO_VIA_CAMERA
 #
 # Platform multimedia device configuration
 #
-source "drivers/media/platform/amphion/Kconfig"
 source "drivers/media/platform/cadence/Kconfig"
 
 source "drivers/media/platform/davinci/Kconfig"
@@ -225,6 +222,22 @@ config VIDEO_TI_CAL_MC
 
 endif # VIDEO_TI_CAL
 
+if VIDEO_MX8_CAPTURE
+
+config VIDEO_ECAM
+        tristate "e-con camera sensor support"
+        depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+        help
+          This config is used to enable codes which are used to
+          support econ camera and to disable ISI control codes.
+
+          To compile this driver as a module, choose M here: the module
+          will be called based on sensor name.
+
+source "drivers/media/platform/imx8/ecam/Kconfig"
+
+endif # VIDEO_MX8_CAPTURE
+
 endif # V4L_PLATFORM_DRIVERS
 
 menuconfig V4L_MEM2MEM_DRIVERS
diff --git a/drivers/media/platform/imx8/Makefile b/drivers/media/platform/imx8/Makefile
index cc57cc26d5b4..ec995e3dad09 100644
--- a/drivers/media/platform/imx8/Makefile
+++ b/drivers/media/platform/imx8/Makefile
@@ -1 +1,6 @@
 obj-$(CONFIG_IMX8_MIPI_CSI2_YAV) += mxc-mipi-csi2_yav.o
+obj-$(CONFIG_MXC_CAMERA_AR0521)   += ar0521.o
+obj-$(CONFIG_MXC_CAMERA_AR1335)   += ar1335.o
+obj-$(CONFIG_MXC_CAMERA_AR0234)   += ar0234.o
+obj-$(CONFIG_MXC_CAMERA_AR1335_AF)   += ar1335_af.o
+obj-$(CONFIG_MXC_CAMERA_AR1335_MCU)   += ar1335_mcu.o
diff --git a/drivers/media/platform/mxc/capture/mx6s_capture.c b/drivers/media/platform/mxc/capture/mx6s_capture.c
index 84f0e40e49e0..2b0d82c007cd 100644
--- a/drivers/media/platform/mxc/capture/mx6s_capture.c
+++ b/drivers/media/platform/mxc/capture/mx6s_capture.c
@@ -50,7 +50,7 @@
 #define MX6S_CAM_VERSION "0.0.1"
 #define MX6S_CAM_DRIVER_DESCRIPTION "i.MX6S_CSI"
 
-#define MAX_VIDEO_MEM 64
+#define MAX_VIDEO_MEM 160
 
 /* reset values */
 #define CSICR1_RESET_VAL	0x40000800
@@ -340,6 +340,7 @@ struct mx6s_csi_dev {
 
 	bool csi_mipi_mode;
 	bool csi_two_8bit_sensor_mode;
+	bool cam_csi_bridge;
 	const struct mx6s_csi_soc *soc;
 	struct mx6s_csi_mux csi_mux;
 };
@@ -865,7 +866,20 @@ static int mx6s_configure_csi(struct mx6s_csi_dev *csi_dev)
 
 		switch (csi_dev->fmt->pixelformat) {
 		case V4L2_PIX_FMT_UYVY:
+			if (csi_dev->cam_csi_bridge)
+			{
+				cr18 &= ~BIT_MIPI_DOUBLE_CMPNT;
+				cr18 &= ~BIT_MIPI_YU_SWAP;
+			}
+			cr18 |= BIT_MIPI_DATA_FORMAT_YUV422_8B;
+			break;
 		case V4L2_PIX_FMT_YUYV:
+			if (csi_dev->cam_csi_bridge)
+			{
+				cr18 |= BIT_MIPI_DOUBLE_CMPNT;
+
+				cr18 |= BIT_MIPI_YU_SWAP;
+			}
 			cr18 |= BIT_MIPI_DATA_FORMAT_YUV422_8B;
 			break;
 		case V4L2_PIX_FMT_SBGGR8:
@@ -1269,13 +1283,19 @@ static struct v4l2_file_operations mx6s_csi_fops = {
 static int mx6s_vidioc_enum_input(struct file *file, void *priv,
 				 struct v4l2_input *inp)
 {
+	struct mx6s_csi_dev *csi_dev = video_drvdata(file);
+	struct v4l2_subdev *sd = csi_dev->sd;
+
 	if (inp->index != 0)
 		return -EINVAL;
 
 	/* default is camera */
 	inp->type = V4L2_INPUT_TYPE_CAMERA;
 	strcpy(inp->name, "Camera");
-
+	if (csi_dev->cam_csi_bridge){
+		if (!v4l2_subdev_has_op(sd, video, s_std))
+			inp->capabilities &= ~V4L2_IN_CAP_STD;
+	}
 	return 0;
 }
 
@@ -1476,9 +1496,38 @@ static int mx6s_vidioc_g_fmt_vid_cap(struct file *file, void *priv,
 				    struct v4l2_format *f)
 {
 	struct mx6s_csi_dev *csi_dev = video_drvdata(file);
+	struct v4l2_subdev *sd = csi_dev->sd;
+	struct v4l2_subdev_format format = {
+		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+	};
+	int ret;
 
 	WARN_ON(priv != file->private_data);
 
+	if (csi_dev->cam_csi_bridge){
+	/*
+	 * Get the format information from the subdev
+	 */
+		ret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &format);
+		if (ret) {
+			pr_info("Error in getting format. ret = %d\n", ret);
+			return ret;
+		}
+		else {
+			struct v4l2_pix_format *pix = &csi_dev->pix;
+			struct mx6s_fmt *fmt;
+
+			v4l2_fill_pix_format(pix, &format.format);
+			if (pix->field != V4L2_FIELD_INTERLACED)
+				pix->field = V4L2_FIELD_NONE;
+
+			fmt = format_by_mbus(format.format.code);
+			pix->pixelformat = fmt->pixelformat;
+			pix->sizeimage = fmt->bpp * pix->height * pix->width;
+			pix->bytesperline = fmt->bpp * pix->width;
+		}
+	}
+
 	f->fmt.pix = csi_dev->pix;
 
 	return 0;
@@ -1623,6 +1672,10 @@ static int mx6s_vidioc_enum_framesizes(struct file *file, void *priv,
 	int ret;
 
 	fmt = format_by_fourcc(fsize->pixel_format);
+
+	if(fmt == NULL)
+		return -EINVAL;
+
 	if (fmt->pixelformat != fsize->pixel_format)
 		return -EINVAL;
 	fse.code = fmt->mbus_code;
@@ -1665,6 +1718,10 @@ static int mx6s_vidioc_enum_frameintervals(struct file *file, void *priv,
 	int ret;
 
 	fmt = format_by_fourcc(interval->pixel_format);
+
+	if(fmt == NULL)
+		return -EINVAL;
+
 	if (fmt->pixelformat != interval->pixel_format)
 		return -EINVAL;
 	fie.code = fmt->mbus_code;
@@ -1677,6 +1734,102 @@ static int mx6s_vidioc_enum_frameintervals(struct file *file, void *priv,
 	return 0;
 }
 
+#ifdef CONFIG_VIDEO_ECAM
+static int mx6s_vidioc_queryctrl(struct file *file, void *priv,
+                             struct v4l2_queryctrl *a)
+{
+        struct mx6s_csi_dev *csi_dev = video_drvdata(file);
+        struct v4l2_subdev *sd = csi_dev->sd;
+
+        return v4l2_subdev_call(sd, core, queryctrl, a);
+}
+
+static int mx6s_vidioc_query_ext_ctrl(struct file *file, void *priv,
+                             struct v4l2_query_ext_ctrl *qec)
+{
+        struct v4l2_queryctrl qc = {
+                .id = qec->id
+        };
+        int ret;
+
+	ret = mx6s_vidioc_queryctrl(file, priv, &qc);
+
+        if (ret)
+                return ret;
+	
+        qec->id = qc.id;
+        qec->type = qc.type;
+        strlcpy(qec->name, qc.name, sizeof(qec->name));
+        qec->maximum = qc.maximum;
+        qec->minimum = qc.minimum;
+        qec->step = qc.step;
+        qec->default_value = qc.default_value;
+        qec->flags = qc.flags;
+        qec->elem_size = 4;
+        qec->elems = 1;
+        qec->nr_of_dims = 0;
+        memset(qec->dims, 0, sizeof(qec->dims));
+        memset(qec->reserved, 0, sizeof(qec->reserved));
+
+        return 0;
+}
+
+static int mx6s_vidioc_querymenu(struct file *file, void *priv,
+                             struct v4l2_querymenu *a)
+{
+        struct mx6s_csi_dev *csi_dev = video_drvdata(file);
+        struct v4l2_subdev *sd = csi_dev->sd;
+
+        return v4l2_subdev_call(sd, core, querymenu, a);
+}
+
+static int mx6s_vidioc_g_ctrl(struct file *file, void *priv,
+                             struct v4l2_control *a)
+{
+        struct mx6s_csi_dev *csi_dev = video_drvdata(file);
+        struct v4l2_subdev *sd = csi_dev->sd;
+
+        return v4l2_subdev_call(sd, core, g_ctrl, a);
+}
+
+static int mx6s_vidioc_s_ctrl(struct file *file, void *priv,
+                             struct v4l2_control *a)
+{
+        struct mx6s_csi_dev *csi_dev = video_drvdata(file);
+        struct v4l2_subdev *sd = csi_dev->sd;
+
+        return v4l2_subdev_call(sd, core, s_ctrl, a);
+}
+
+static int mx6s_vidioc_g_ext_ctrls(struct file *file, void *priv,
+                             struct v4l2_ext_controls *a)
+{
+        struct mx6s_csi_dev *csi_dev = video_drvdata(file);
+        struct v4l2_subdev *sd = csi_dev->sd;
+
+        return v4l2_subdev_call(sd, core, g_ext_ctrls, a);
+}
+
+static int mx6s_vidioc_s_ext_ctrls(struct file *file, void *priv,
+                             struct v4l2_ext_controls *a)
+{
+        struct mx6s_csi_dev *csi_dev = video_drvdata(file);
+        struct v4l2_subdev *sd = csi_dev->sd;
+
+        return v4l2_subdev_call(sd, core, s_ext_ctrls, a);
+}
+
+static int mx6s_vidioc_try_ext_ctrls(struct file *file, void *priv,
+                             struct v4l2_ext_controls *a)
+{
+        struct mx6s_csi_dev *csi_dev = video_drvdata(file);
+        struct v4l2_subdev *sd = csi_dev->sd;
+
+        return v4l2_subdev_call(sd, core, try_ext_ctrls, a);
+}
+
+#endif
+
 static const struct v4l2_ioctl_ops mx6s_csi_ioctl_ops = {
 	.vidioc_querycap          = mx6s_vidioc_querycap,
 	.vidioc_enum_fmt_vid_cap  = mx6s_vidioc_enum_fmt_vid_cap,
@@ -1703,6 +1856,16 @@ static const struct v4l2_ioctl_ops mx6s_csi_ioctl_ops = {
 	.vidioc_s_parm        = mx6s_vidioc_s_parm,
 	.vidioc_enum_framesizes = mx6s_vidioc_enum_framesizes,
 	.vidioc_enum_frameintervals = mx6s_vidioc_enum_frameintervals,
+#ifdef CONFIG_VIDEO_ECAM
+        .vidioc_queryctrl       = mx6s_vidioc_queryctrl,
+        .vidioc_query_ext_ctrl  = mx6s_vidioc_query_ext_ctrl,
+        .vidioc_querymenu       = mx6s_vidioc_querymenu,
+        .vidioc_g_ctrl          = mx6s_vidioc_g_ctrl,
+        .vidioc_s_ctrl          = mx6s_vidioc_s_ctrl,
+        .vidioc_g_ext_ctrls     = mx6s_vidioc_g_ext_ctrls,
+        .vidioc_s_ext_ctrls     = mx6s_vidioc_s_ext_ctrls,
+        .vidioc_try_ext_ctrls   = mx6s_vidioc_try_ext_ctrls
+#endif
 };
 
 static int subdev_notifier_bound(struct v4l2_async_notifier *notifier,
@@ -1891,6 +2054,12 @@ static int mx6s_csi_probe(struct platform_device *pdev)
 	mx6s_csi_mode_sel(csi_dev);
 	mx6s_csi_two_8bit_sensor_mode_sel(csi_dev);
 
+	/*
+	* Add a flag to identify the cam device tree
+	*/
+	csi_dev->cam_csi_bridge =
+		of_property_read_bool(csi_dev->dev->of_node, "cam-csi-bridge");
+
 	of_id = of_match_node(mx6s_csi_dt_ids, csi_dev->dev->of_node);
 	if (!of_id)
 		return -EINVAL;
diff --git a/drivers/media/platform/mxc/capture/mxc_mipi_csi.c b/drivers/media/platform/mxc/capture/mxc_mipi_csi.c
index a722f38fedd5..c06f1fd0f78e 100644
--- a/drivers/media/platform/mxc/capture/mxc_mipi_csi.c
+++ b/drivers/media/platform/mxc/capture/mxc_mipi_csi.c
@@ -271,6 +271,7 @@ struct csi_state {
 	struct clk *disp_apb;
 	int irq;
 	u32 flags;
+	bool cam_format_change;
 
 	u32 clk_frequency;
 	u32 hs_settle;
@@ -317,6 +318,10 @@ static const struct csis_pix_format mipi_csis_formats[] = {
 		.code = MEDIA_BUS_FMT_VYUY8_2X8,
 		.fmt_reg = MIPI_CSIS_ISPCFG_FMT_YCBCR422_8BIT,
 		.data_alignment = 16,
+	}, {
+                .code = MEDIA_BUS_FMT_UYVY8_2X8,
+                .fmt_reg = MIPI_CSIS_ISPCFG_FMT_YCBCR422_8BIT,
+                .data_alignment = 16,
 	}, {
 		.code = MEDIA_BUS_FMT_SBGGR8_1X8,
 		.fmt_reg = MIPI_CSIS_ISPCFG_FMT_RAW8,
@@ -508,6 +513,8 @@ static void mipi_csis_set_params(struct csi_state *state)
 		val |= MIPI_CSIS_ISPCFG_ALIGN_32BIT;
 	else /* Normal output */
 		val &= ~MIPI_CSIS_ISPCFG_ALIGN_32BIT;
+	if (state->cam_format_change)
+		val |= 1 << 12; /*Dual Pixel Mode */
 	mipi_csis_write(state, MIPI_CSIS_ISPCONFIG_CH0, val);
 
 	val = (0 << MIPI_CSIS_ISPSYNC_HSYNC_LINTV_OFFSET) |
@@ -667,13 +674,16 @@ static int mipi_csis_s_power(struct v4l2_subdev *mipi_sd, int on)
 {
 	struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
 	struct device *dev = &state->pdev->dev;
+	int ret = 0;
 
-	v4l2_subdev_call(state->sensor_sd, core, s_power, on);
-
+	ret = v4l2_subdev_call(state->sensor_sd, core, s_power, on);
+#if 0
 	if (on)
 		return pm_runtime_get_sync(dev);
 
 	return pm_runtime_put_sync(dev);
+#endif
+	return ret;
 }
 
 static int mipi_csis_s_stream(struct v4l2_subdev *mipi_sd, int enable)
@@ -840,6 +850,65 @@ static int mipi_csis_enum_frameintervals(struct v4l2_subdev *mipi_sd,
 	return v4l2_subdev_call(sensor_sd, pad, enum_frame_interval, NULL, fie);
 }
 
+#ifdef CONFIG_VIDEO_ECAM
+
+static int mipi_csis_queryctrl(struct v4l2_subdev *mipi_sd, struct v4l2_queryctrl *qc)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sensor_sd = state->sensor_sd;
+
+	return v4l2_subdev_call(sensor_sd, core, queryctrl, qc);
+}
+
+static int mipi_csis_g_ctrl(struct v4l2_subdev *mipi_sd, struct v4l2_control *ctrl)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sensor_sd = state->sensor_sd;
+
+        return v4l2_subdev_call(sensor_sd, core, g_ctrl, ctrl);
+}
+
+static int mipi_csis_s_ctrl(struct v4l2_subdev *mipi_sd, struct v4l2_control *ctrl)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sensor_sd = state->sensor_sd;
+
+        return v4l2_subdev_call(sensor_sd, core, s_ctrl, ctrl);
+}
+
+static int mipi_csis_g_ext_ctrls(struct v4l2_subdev *mipi_sd, struct v4l2_ext_controls *ctrls)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sensor_sd = state->sensor_sd;
+
+        return v4l2_subdev_call(sensor_sd, core, g_ext_ctrls, ctrls);
+}
+
+static int mipi_csis_s_ext_ctrls(struct v4l2_subdev *mipi_sd, struct v4l2_ext_controls *ctrls)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sensor_sd = state->sensor_sd;
+
+        return v4l2_subdev_call(sensor_sd, core, s_ext_ctrls, ctrls);
+}
+
+static int mipi_csis_try_ext_ctrls(struct v4l2_subdev *mipi_sd, struct v4l2_ext_controls *ctrls)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sensor_sd = state->sensor_sd;
+
+        return v4l2_subdev_call(sensor_sd, core, try_ext_ctrls, ctrls);
+}
+
+static int mipi_csis_querymenu(struct v4l2_subdev *mipi_sd, struct v4l2_querymenu *qm)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sensor_sd = state->sensor_sd;
+
+        return v4l2_subdev_call(sensor_sd, core, querymenu, qm);
+}
+#endif
+
 static int mipi_csis_log_status(struct v4l2_subdev *mipi_sd)
 {
 	struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
@@ -855,6 +924,15 @@ static int mipi_csis_log_status(struct v4l2_subdev *mipi_sd)
 static struct v4l2_subdev_core_ops mipi_csis_core_ops = {
 	.s_power = mipi_csis_s_power,
 	.log_status = mipi_csis_log_status,
+#ifdef CONFIG_VIDEO_ECAM
+	.queryctrl = mipi_csis_queryctrl,
+        .g_ctrl = mipi_csis_g_ctrl,
+        .s_ctrl = mipi_csis_s_ctrl,
+        .g_ext_ctrls = mipi_csis_g_ext_ctrls,
+        .s_ext_ctrls = mipi_csis_s_ext_ctrls,
+        .try_ext_ctrls = mipi_csis_try_ext_ctrls,
+        .querymenu = mipi_csis_querymenu,
+#endif
 };
 
 static struct v4l2_subdev_video_ops mipi_csis_video_ops = {
@@ -961,6 +1039,7 @@ static int mipi_csis_parse_dt(struct platform_device *pdev,
 	}
 
 	/* Get MIPI CSI-2 bus configration from the endpoint node. */
+	state->cam_format_change = of_property_read_bool(node, "cam-format-change");
 	of_property_read_u32(node, "csis-hs-settle",
 					&state->hs_settle);
 
@@ -1163,7 +1242,8 @@ static int mipi_csis_probe(struct platform_device *pdev)
 			goto e_sd_host;
 	}
 
-	mipi_csis_clk_disable(state);
+	if (!(state->cam_format_change))
+		mipi_csis_clk_disable(state);
 	dev_info(&pdev->dev,
 			"lanes: %d, hs_settle: %d, clk_settle: %d, wclk: %d, freq: %u\n",
 		 state->num_lanes, state->hs_settle, state->clk_settle,
diff --git a/drivers/mtd/spi-nor/winbond.c b/drivers/mtd/spi-nor/winbond.c
index 96573f61caf5..e7752b4296ab 100644
--- a/drivers/mtd/spi-nor/winbond.c
+++ b/drivers/mtd/spi-nor/winbond.c
@@ -91,6 +91,9 @@ static const struct flash_info winbond_parts[] = {
 	{ "w25q80", INFO(0xef5014, 0, 64 * 1024,  16, SECT_4K) },
 	{ "w25q80bl", INFO(0xef4014, 0, 64 * 1024,  16, SECT_4K) },
 	{ "w25q128", INFO(0xef4018, 0, 64 * 1024, 256, SECT_4K) },
+	{ "w25q128dw", INFO(0x1f4218, 0, 64 * 1024, 256,
+			   SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
+			   SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB) },
 	{ "w25q256", INFO(0xef4019, 0, 64 * 1024, 512,
 			  SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)
 	  .fixups = &w25q256_fixups },
diff --git a/drivers/staging/Kconfig b/drivers/staging/Kconfig
index aebb2afec2e9..57afd20a8f99 100644
--- a/drivers/staging/Kconfig
+++ b/drivers/staging/Kconfig
@@ -109,5 +109,6 @@ source "drivers/staging/wfx/Kconfig"
 source "drivers/staging/fsl_ppfe/Kconfig"
 
 source "drivers/staging/ethosu/Kconfig"
+source "drivers/staging/em9190/Kconfig"
 
 endif # STAGING
diff --git a/drivers/staging/Makefile b/drivers/staging/Makefile
index 15859d05b48c..370499d4258b 100644
--- a/drivers/staging/Makefile
+++ b/drivers/staging/Makefile
@@ -45,3 +45,4 @@ obj-$(CONFIG_QLGE)		+= qlge/
 obj-$(CONFIG_WFX)		+= wfx/
 obj-$(CONFIG_FSL_PPFE)		+= fsl_ppfe/
 obj-$(CONFIG_ETHOSU)		+= ethosu/
+obj-$(CONFIG_EM9190)		+= em9190/
diff --git a/drivers/staging/media/imx/imx8-isi-cap.c b/drivers/staging/media/imx/imx8-isi-cap.c
index 6f83ba47f919..18e365ea79e1 100644
--- a/drivers/staging/media/imx/imx8-isi-cap.c
+++ b/drivers/staging/media/imx/imx8-isi-cap.c
@@ -54,6 +54,14 @@ struct mxc_isi_fmt mxc_isi_src_formats[] = {
 		.memplanes	= 1,
 		.colplanes	= 1,
 		.align		= 2,
+	}, {
+		.name		= "UYVY-16",
+		.fourcc		= V4L2_PIX_FMT_UYVY,
+		.depth		= { 16 },
+		.color		= MXC_ISI_OUT_FMT_YUV422_1P8P,
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.mbus_code	= MEDIA_BUS_FMT_UYVY8_2X8,
 	}
 };
 
@@ -495,6 +503,8 @@ static struct vb2_ops mxc_cap_vb2_qops = {
 	.stop_streaming		= cap_vb2_stop_streaming,
 };
 
+/* To enable ctrls in sensor driver, we need to comment the ISI ctrls */
+#ifndef CONFIG_VIDEO_ECAM
 /*
  * V4L2 controls handling
  */
@@ -584,6 +594,7 @@ void mxc_isi_ctrls_delete(struct mxc_isi_cap_dev *isi_cap)
 		ctrls->alpha = NULL;
 	}
 }
+#endif
 
 static struct media_pad
 *mxc_isi_get_remote_source_pad(struct v4l2_subdev *subdev)
@@ -1370,6 +1381,129 @@ static int mxc_isi_cap_enum_frameintervals(struct file *file, void *fh,
 	return 0;
 }
 
+#ifdef CONFIG_VIDEO_ECAM
+static int mxc_vidioc_queryctrl(struct file *file, void *fh,
+					struct v4l2_queryctrl *a)
+{
+	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
+	struct v4l2_subdev *sd;
+
+	sd = mxc_get_remote_subdev(&isi_cap->sd, __func__);
+	if (!sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sd, core, queryctrl, a);
+}
+
+static int mxc_vidioc_query_ext_ctrl(struct file *file, void *fh,
+					struct v4l2_query_ext_ctrl *qec)
+{
+	struct v4l2_queryctrl qc = {
+		.id = qec->id
+	};
+	int ret;
+
+	ret = mxc_vidioc_queryctrl(file, fh, &qc);
+
+	if (ret)
+		return ret;
+
+	qec->id = qc.id;
+	qec->type = qc.type;
+	strlcpy(qec->name, qc.name, sizeof(qec->name));
+	qec->maximum = qc.maximum;
+	qec->minimum = qc.minimum;
+	qec->step = qc.step;
+	qec->default_value = qc.default_value;
+	qec->flags = qc.flags;
+	qec->elem_size = 4;
+	qec->elems = 1;
+	qec->nr_of_dims = 0;
+	memset(qec->dims, 0, sizeof(qec->dims));
+	memset(qec->reserved, 0, sizeof(qec->reserved));
+
+	return 0;
+}
+
+static int mxc_isi_vidioc_querymenu(struct file *file, void *fh,
+					struct v4l2_querymenu *qm)
+{
+	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
+	struct v4l2_subdev *sd;
+
+	sd = mxc_get_remote_subdev(&isi_cap->sd, __func__);
+	if (!sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sd, core, querymenu, qm);
+}
+
+static int mxc_isi_vidioc_g_ctrl(struct file *file, void *fh,
+					struct v4l2_control *a)
+{
+	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
+	struct v4l2_subdev *sd;
+
+	sd = mxc_get_remote_subdev(&isi_cap->sd, __func__);
+	if (!sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sd, core, g_ctrl, a);
+}
+
+static int mxc_isi_vidioc_s_ctrl(struct file *file, void *fh,
+					struct v4l2_control *a)
+{
+	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
+	struct v4l2_subdev *sd;
+
+	sd = mxc_get_remote_subdev(&isi_cap->sd, __func__);
+	if (!sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sd, core, s_ctrl, a);
+}
+
+static int mxc_isi_vidioc_g_ext_ctrls(struct file *file, void *fh,
+				  struct v4l2_ext_controls *a)
+{
+	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
+	struct v4l2_subdev *sd;
+
+	sd = mxc_get_remote_subdev(&isi_cap->sd, __func__);
+	if (!sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sd, core, g_ext_ctrls, a);
+}
+
+static int mxc_isi_vidioc_try_ext_ctrls(struct file *file, void *fh,
+				  struct v4l2_ext_controls *a)
+{
+	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
+	struct v4l2_subdev *sd;
+
+	sd = mxc_get_remote_subdev(&isi_cap->sd, __func__);
+	if (!sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sd, core, try_ext_ctrls, a);
+}
+
+static int mxc_isi_vidioc_s_ext_ctrls(struct file *file, void *fh,
+				  struct v4l2_ext_controls *a)
+{
+	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
+	struct v4l2_subdev *sd;
+
+	sd = mxc_get_remote_subdev(&isi_cap->sd, __func__);
+	if (!sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sd, core, s_ext_ctrls, a);
+}
+#endif
+
 static const struct v4l2_ioctl_ops mxc_isi_capture_ioctl_ops = {
 	.vidioc_querycap		= mxc_isi_cap_querycap,
 
@@ -1400,6 +1534,16 @@ static const struct v4l2_ioctl_ops mxc_isi_capture_ioctl_ops = {
 
 	.vidioc_subscribe_event   =  v4l2_ctrl_subscribe_event,
 	.vidioc_unsubscribe_event =  v4l2_event_unsubscribe,
+#ifdef CONFIG_VIDEO_ECAM
+	.vidioc_queryctrl	= mxc_vidioc_queryctrl,
+	.vidioc_query_ext_ctrl	= mxc_vidioc_query_ext_ctrl,
+	.vidioc_querymenu	= mxc_isi_vidioc_querymenu,
+	.vidioc_g_ctrl		= mxc_isi_vidioc_g_ctrl,
+	.vidioc_s_ctrl		= mxc_isi_vidioc_s_ctrl,
+	.vidioc_g_ext_ctrls	= mxc_isi_vidioc_g_ext_ctrls,
+	.vidioc_s_ext_ctrls	= mxc_isi_vidioc_s_ext_ctrls,
+	.vidioc_try_ext_ctrls	= mxc_isi_vidioc_try_ext_ctrls
+#endif
 };
 
 /* Capture subdev media entity operations */
@@ -1713,23 +1857,29 @@ static int mxc_isi_register_cap_device(struct mxc_isi_cap_dev *isi_cap,
 	if (ret)
 		goto err_free_ctx;
 
+#ifndef CONFIG_VIDEO_ECAM
 	ret = mxc_isi_ctrls_create(isi_cap);
 	if (ret)
 		goto err_me_cleanup;
+#endif
 
 	ret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);
 	if (ret)
 		goto err_ctrl_free;
 
+#ifndef CONFIG_VIDEO_ECAM
 	vdev->ctrl_handler = &isi_cap->ctrls.handler;
+#endif
 	v4l2_info(v4l2_dev, "Registered %s as /dev/%s\n",
 		  vdev->name, video_device_node_name(vdev));
 
 	return 0;
 
 err_ctrl_free:
+#ifndef CONFIG_VIDEO_ECAM
 	mxc_isi_ctrls_delete(isi_cap);
 err_me_cleanup:
+#endif
 	media_entity_cleanup(&vdev->entity);
 err_free_ctx:
 	return ret;
@@ -1766,7 +1916,10 @@ static void mxc_isi_subdev_unregistered(struct v4l2_subdev *sd)
 	vdev = &isi_cap->vdev;
 	if (video_is_registered(vdev)) {
 		video_unregister_device(vdev);
+/* To enable ctrls in sensor driver, we need to comment the ISI ctrls*/
+#ifndef CONFIG_VIDEO_ECAM
 		mxc_isi_ctrls_delete(isi_cap);
+#endif
 		media_entity_cleanup(&vdev->entity);
 	}
 	mutex_unlock(&isi_cap->lock);
diff --git a/drivers/staging/media/imx/imx8-isi-hw.c b/drivers/staging/media/imx/imx8-isi-hw.c
index 193ff5c5fd33..d5b04e7eff46 100644
--- a/drivers/staging/media/imx/imx8-isi-hw.c
+++ b/drivers/staging/media/imx/imx8-isi-hw.c
@@ -125,6 +125,7 @@ static bool is_yuv(u32 pix_fmt)
 	if ((pix_fmt == V4L2_PIX_FMT_YUYV)  ||
 	    (pix_fmt == V4L2_PIX_FMT_YUV32) ||
 	    (pix_fmt == V4L2_PIX_FMT_YUV444M) ||
+	    (pix_fmt == V4L2_PIX_FMT_YUV24) ||
 	    (pix_fmt == V4L2_PIX_FMT_NV12))
 		return true;
 	else
diff --git a/drivers/staging/media/imx/imx8-mipi-csi2-sam.c b/drivers/staging/media/imx/imx8-mipi-csi2-sam.c
index 1d12365520a6..8701978ad4f2 100644
--- a/drivers/staging/media/imx/imx8-mipi-csi2-sam.c
+++ b/drivers/staging/media/imx/imx8-mipi-csi2-sam.c
@@ -1272,6 +1272,144 @@ static int mipi_csis_enum_frameintervals(struct v4l2_subdev *mipi_sd,
 	return v4l2_subdev_call(sen_sd, pad, enum_frame_interval, NULL, fie);
 }
 
+#ifdef CONFIG_VIDEO_ECAM
+
+static int mipi_csis_s_parm(struct v4l2_subdev *mipi_sd, struct v4l2_streamparm *a)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sen_sd;
+
+        /* Get remote source pad subdev */
+        sen_sd = csis_get_remote_subdev(state, __func__);
+        if (!sen_sd) {
+                v4l2_err(&state->sd, "%s, No remote subdev found!\n", __func__);
+                return -EINVAL;
+        }
+
+        return v4l2_subdev_call(sen_sd, video, s_parm, a);
+}
+
+static int mipi_csis_g_parm(struct v4l2_subdev *mipi_sd, struct v4l2_streamparm *a)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sen_sd;
+
+        /* Get remote source pad subdev */
+        sen_sd = csis_get_remote_subdev(state, __func__);
+        if (!sen_sd) {
+                v4l2_err(&state->sd, "%s, No remote subdev found!\n", __func__);
+                return -EINVAL;
+        }
+
+        return v4l2_subdev_call(sen_sd, video, g_parm, a);
+}
+
+static int mipi_csis_queryctrl(struct v4l2_subdev *mipi_sd, struct v4l2_queryctrl *qc)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sen_sd;
+
+        /* Get remote source pad subdev */
+        sen_sd = csis_get_remote_subdev(state, __func__);
+        if (!sen_sd) {
+                v4l2_err(&state->sd, "%s, No remote subdev found!\n", __func__);
+                return -EINVAL;
+        }
+
+	return v4l2_subdev_call(sen_sd, core, queryctrl, qc);
+}
+
+static int mipi_csis_g_ctrl(struct v4l2_subdev *mipi_sd, struct v4l2_control *ctrl)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sen_sd;
+
+        /* Get remote source pad subdev */
+        sen_sd = csis_get_remote_subdev(state, __func__);
+        if (!sen_sd) {
+                v4l2_err(&state->sd, "%s, No remote subdev found!\n", __func__);
+                return -EINVAL;
+        }
+
+	return v4l2_subdev_call(sen_sd, core, g_ctrl, ctrl);
+}
+
+static int mipi_csis_s_ctrl(struct v4l2_subdev *mipi_sd, struct v4l2_control *ctrl)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sen_sd;
+
+        /* Get remote source pad subdev */
+        sen_sd = csis_get_remote_subdev(state, __func__);
+        if (!sen_sd) {
+                v4l2_err(&state->sd, "%s, No remote subdev found!\n", __func__);
+                return -EINVAL;
+        }
+
+	return v4l2_subdev_call(sen_sd, core, s_ctrl, ctrl);
+}
+
+static int mipi_csis_g_ext_ctrls(struct v4l2_subdev *mipi_sd, struct v4l2_ext_controls *ctrls)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sen_sd;
+
+        /* Get remote source pad subdev */
+        sen_sd = csis_get_remote_subdev(state, __func__);
+        if (!sen_sd) {
+                v4l2_err(&state->sd, "%s, No remote subdev found!\n", __func__);
+                return -EINVAL;
+        }
+
+	return v4l2_subdev_call(sen_sd, core, g_ext_ctrls, ctrls);
+}
+
+static int mipi_csis_s_ext_ctrls(struct v4l2_subdev *mipi_sd, struct v4l2_ext_controls *ctrls)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sen_sd;
+
+        /* Get remote source pad subdev */
+        sen_sd = csis_get_remote_subdev(state, __func__);
+        if (!sen_sd) {
+                v4l2_err(&state->sd, "%s, No remote subdev found!\n", __func__);
+                return -EINVAL;
+        }
+
+	return v4l2_subdev_call(sen_sd, core, s_ext_ctrls, ctrls);
+}
+
+static int mipi_csis_try_ext_ctrls(struct v4l2_subdev *mipi_sd, struct v4l2_ext_controls *ctrls)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sen_sd;
+
+        /* Get remote source pad subdev */
+        sen_sd = csis_get_remote_subdev(state, __func__);
+        if (!sen_sd) {
+                v4l2_err(&state->sd, "%s, No remote subdev found!\n", __func__);
+                return -EINVAL;
+        }
+
+	return v4l2_subdev_call(sen_sd, core, try_ext_ctrls, ctrls);
+}
+
+static int mipi_csis_querymenu(struct v4l2_subdev *mipi_sd, struct v4l2_querymenu *qm)
+{
+        struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
+        struct v4l2_subdev *sen_sd;
+
+        /* Get remote source pad subdev */
+        sen_sd = csis_get_remote_subdev(state, __func__);
+        if (!sen_sd) {
+                v4l2_err(&state->sd, "%s, No remote subdev found!\n", __func__);
+                return -EINVAL;
+        }
+
+	return v4l2_subdev_call(sen_sd, core, querymenu, qm);
+}
+#endif
+
 static int mipi_csis_log_status(struct v4l2_subdev *mipi_sd)
 {
 	struct csi_state *state = mipi_sd_to_csi_state(mipi_sd);
@@ -1417,12 +1555,25 @@ static struct v4l2_subdev_core_ops mipi_csis_core_ops = {
 	.s_power = mipi_csis_s_power,
 	.log_status = mipi_csis_log_status,
 	.ioctl = csis_priv_ioctl,
+#ifdef CONFIG_VIDEO_ECAM
+	.queryctrl = mipi_csis_queryctrl,
+        .g_ctrl = mipi_csis_g_ctrl,
+        .s_ctrl = mipi_csis_s_ctrl,
+        .g_ext_ctrls = mipi_csis_g_ext_ctrls,
+        .s_ext_ctrls = mipi_csis_s_ext_ctrls,
+        .try_ext_ctrls = mipi_csis_try_ext_ctrls,
+        .querymenu = mipi_csis_querymenu,
+#endif
 };
 
 static struct v4l2_subdev_video_ops mipi_csis_video_ops = {
 	.s_rx_buffer = mipi_csis_s_rx_buffer,
 	.s_stream = mipi_csis_s_stream,
 
+#ifdef CONFIG_VIDEO_ECAM
+        .s_parm = mipi_csis_s_parm,
+        .g_parm = mipi_csis_g_parm,
+#endif
 	.g_frame_interval = mipi_csis_g_frame_interval,
 	.s_frame_interval = mipi_csis_s_frame_interval,
 };
diff --git a/drivers/staging/media/imx/imx8-mipi-csi2.c b/drivers/staging/media/imx/imx8-mipi-csi2.c
index 3c628fb1becd..6bc71b44c413 100644
--- a/drivers/staging/media/imx/imx8-mipi-csi2.c
+++ b/drivers/staging/media/imx/imx8-mipi-csi2.c
@@ -1031,6 +1031,93 @@ static const struct media_entity_operations mipi_csi2_sd_media_ops = {
 /*
  * V4L2 subdev operations
  */
+#ifdef CONFIG_VIDEO_ECAM
+static int mipi_csi2_querymenu(struct v4l2_subdev *sd, struct v4l2_querymenu *qm)
+{
+	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
+	struct v4l2_subdev *sen_sd;
+
+	sen_sd = mxc_get_remote_subdev(csi2dev, __func__);
+	if (!sen_sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sen_sd, core, querymenu, qm);
+}
+
+static int mipi_csi2_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
+	struct v4l2_subdev *sen_sd;
+
+	sen_sd = mxc_get_remote_subdev(csi2dev, __func__);
+	if (!sen_sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sen_sd, core, queryctrl, qc);
+}
+
+static int mipi_csi2_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
+	struct v4l2_subdev *sen_sd;
+
+	sen_sd = mxc_get_remote_subdev(csi2dev, __func__);
+	if (!sen_sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sen_sd, core, g_ctrl, ctrl);
+}
+
+static int mipi_csi2_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+
+	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
+	struct v4l2_subdev *sen_sd;
+
+	sen_sd = mxc_get_remote_subdev(csi2dev, __func__);
+	if (!sen_sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sen_sd, core, s_ctrl, ctrl);
+}
+
+static int mipi_csi2_g_ext_ctrls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ctrls)
+{
+	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
+	struct v4l2_subdev *sen_sd;
+
+	sen_sd = mxc_get_remote_subdev(csi2dev, __func__);
+	if (!sen_sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sen_sd, core, g_ext_ctrls, ctrls);
+}
+
+static int mipi_csi2_try_ext_ctrls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ctrls)
+{
+	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
+	struct v4l2_subdev *sen_sd;
+
+	sen_sd = mxc_get_remote_subdev(csi2dev, __func__);
+	if (!sen_sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sen_sd, core, try_ext_ctrls, ctrls);
+}
+
+static int mipi_csi2_s_ext_ctrls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ctrls)
+{
+	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
+	struct v4l2_subdev *sen_sd;
+
+	sen_sd = mxc_get_remote_subdev(csi2dev, __func__);
+	if (!sen_sd)
+		return -EINVAL;
+
+	return v4l2_subdev_call(sen_sd, core, s_ext_ctrls, ctrls);
+}
+#endif
+
 static int mipi_csi2_s_power(struct v4l2_subdev *sd, int on)
 {
 	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
@@ -1182,6 +1269,15 @@ static struct v4l2_subdev_pad_ops mipi_csi2_pad_ops = {
 
 static struct v4l2_subdev_core_ops mipi_csi2_core_ops = {
 	.s_power = mipi_csi2_s_power,
+#ifdef CONFIG_VIDEO_ECAM
+	.queryctrl = mipi_csi2_queryctrl,
+	.g_ctrl = mipi_csi2_g_ctrl,
+	.s_ctrl = mipi_csi2_s_ctrl,
+	.g_ext_ctrls = mipi_csi2_g_ext_ctrls,
+	.s_ext_ctrls = mipi_csi2_s_ext_ctrls,
+	.try_ext_ctrls = mipi_csi2_try_ext_ctrls,
+	.querymenu = mipi_csi2_querymenu,
+#endif
 };
 
 static struct v4l2_subdev_video_ops mipi_csi2_video_ops = {
diff --git a/include/media/v4l2-subdev.h b/include/media/v4l2-subdev.h
index f3b840a2c1f1..5ab1a03a44d5 100644
--- a/include/media/v4l2-subdev.h
+++ b/include/media/v4l2-subdev.h
@@ -198,6 +198,15 @@ struct v4l2_subdev_core_ops {
 	int (*load_fw)(struct v4l2_subdev *sd);
 	int (*reset)(struct v4l2_subdev *sd, u32 val);
 	int (*s_gpio)(struct v4l2_subdev *sd, u32 val);
+#ifdef CONFIG_VIDEO_ECAM
+	int (*queryctrl)(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc);
+	int (*g_ctrl)(struct v4l2_subdev *sd, struct v4l2_control *ctrl);
+	int (*s_ctrl)(struct v4l2_subdev *sd, struct v4l2_control *ctrl);
+	int (*querymenu)(struct v4l2_subdev *sd, struct v4l2_querymenu *qm);
+	int (*g_ext_ctrls)(struct v4l2_subdev *sd, struct v4l2_ext_controls *ctrls);
+	int (*s_ext_ctrls)(struct v4l2_subdev *sd, struct v4l2_ext_controls *ctrls);
+	int (*try_ext_ctrls)(struct v4l2_subdev *sd, struct v4l2_ext_controls *ctrls);
+#endif
 	long (*command)(struct v4l2_subdev *sd, unsigned int cmd, void *arg);
 	long (*ioctl)(struct v4l2_subdev *sd, unsigned int cmd, void *arg);
 #ifdef CONFIG_COMPAT
-- 
2.17.1

